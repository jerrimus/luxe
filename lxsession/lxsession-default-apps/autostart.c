/* autostart.c generated by valac 0.34.7, the Vala compiler
 * generated from autostart.vala, do not modify */

/* 
    Copyright 2013 Julien Lavergne <gilir@ubuntu.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <stdio.h>
#include <glib/gstdio.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block1Data Block1Data;
typedef struct _Block2Data Block2Data;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _Block3Data Block3Data;
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))

#define LDEFAULT_APPS_TYPE_DBUS_BACKEND (ldefault_apps_dbus_backend_get_type ())
#define LDEFAULT_APPS_DBUS_BACKEND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LDEFAULT_APPS_TYPE_DBUS_BACKEND, LDefaultAppsDbusBackend))
#define LDEFAULT_APPS_DBUS_BACKEND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LDEFAULT_APPS_TYPE_DBUS_BACKEND, LDefaultAppsDbusBackendClass))
#define LDEFAULT_APPS_IS_DBUS_BACKEND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LDEFAULT_APPS_TYPE_DBUS_BACKEND))
#define LDEFAULT_APPS_IS_DBUS_BACKEND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LDEFAULT_APPS_TYPE_DBUS_BACKEND))
#define LDEFAULT_APPS_DBUS_BACKEND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LDEFAULT_APPS_TYPE_DBUS_BACKEND, LDefaultAppsDbusBackendClass))

typedef struct _LDefaultAppsDbusBackend LDefaultAppsDbusBackend;
typedef struct _LDefaultAppsDbusBackendClass LDefaultAppsDbusBackendClass;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _Block1Data {
	int _ref_count_;
	GtkBuilder* builder;
};

struct _Block2Data {
	int _ref_count_;
	Block1Data * _data1_;
	GtkEntry* add_entry;
};

struct _Block3Data {
	int _ref_count_;
	Block2Data * _data2_;
	GtkCheckButton* check;
};



gchar* ldefault_apps_read_autostart_conf (void);
gchar* ldefault_apps_get_config_home_path (const gchar* conf_file);
gchar* ldefault_apps_get_config_path (const gchar* conf_file);
void ldefault_apps_manual_autostart_init (GtkBuilder* builder);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static void ____lambda4_ (Block3Data* _data3_);
void ldefault_apps_update_autostart_conf (const gchar* line, const gchar* action, GtkBuilder* builder);
static void _____lambda4__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void ____lambda5_ (Block3Data* _data3_);
static void _____lambda5__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void ___lambda6_ (Block2Data* _data2_);
static void ____lambda6__gtk_button_clicked (GtkButton* _sender, gpointer self);
GType ldefault_apps_dbus_backend_get_type (void) G_GNUC_CONST;
void ldefault_apps_autostart_core_applications (GtkBuilder* builder, LDefaultAppsDbusBackend* dbus_backend);
static gchar** _vala_array_dup1 (gchar** self, int length);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


gchar* ldefault_apps_read_autostart_conf (void) {
	gchar* result = NULL;
	gchar* config_path = NULL;
	gchar* _tmp0_ = NULL;
	GFile* config_file = NULL;
	const gchar* _tmp1_ = NULL;
	GFile* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp27_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = ldefault_apps_get_config_home_path ("autostart");
	_g_free0 (config_path);
	config_path = _tmp0_;
	_tmp1_ = config_path;
	_tmp2_ = g_file_new_for_path (_tmp1_);
	config_file = _tmp2_;
	_tmp3_ = config_file;
	_tmp4_ = g_file_query_exists (_tmp3_, NULL);
	if (!_tmp4_) {
		gchar* config_system_path = NULL;
		gchar* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		_tmp5_ = ldefault_apps_get_config_path ("autostart");
		_g_free0 (config_system_path);
		config_system_path = _tmp5_;
		_tmp6_ = config_system_path;
		if (_tmp6_ == NULL) {
			{
				GFile* blank_file = NULL;
				const gchar* _tmp7_ = NULL;
				GFile* _tmp8_ = NULL;
				GFile* _tmp9_ = NULL;
				GFileOutputStream* _tmp10_ = NULL;
				GFileOutputStream* _tmp11_ = NULL;
				g_message ("autostart.vala:36: Create blank file");
				_tmp7_ = config_path;
				_tmp8_ = g_file_new_for_path (_tmp7_);
				blank_file = _tmp8_;
				_tmp9_ = blank_file;
				_tmp10_ = g_file_create (_tmp9_, G_FILE_CREATE_PRIVATE, NULL, &_inner_error_);
				_tmp11_ = _tmp10_;
				_g_object_unref0 (_tmp11_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (blank_file);
					goto __catch0_g_error;
				}
				_g_object_unref0 (blank_file);
			}
			goto __finally0;
			__catch0_g_error:
			{
				GError* e = NULL;
				GError* _tmp12_ = NULL;
				const gchar* _tmp13_ = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp12_ = e;
				_tmp13_ = _tmp12_->message;
				g_message ("autostart.vala:42: %s", _tmp13_);
				_g_error_free0 (e);
			}
			__finally0:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (config_system_path);
				_g_object_unref0 (config_file);
				_g_free0 (config_path);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		} else {
			GFile* file = NULL;
			const gchar* _tmp14_ = NULL;
			GFile* _tmp15_ = NULL;
			GFile* config_parent = NULL;
			GFile* _tmp16_ = NULL;
			GFile* _tmp17_ = NULL;
			GFile* _tmp18_ = NULL;
			gboolean _tmp19_ = FALSE;
			_tmp14_ = config_system_path;
			_tmp15_ = g_file_new_for_path (_tmp14_);
			file = _tmp15_;
			_tmp16_ = config_file;
			_tmp17_ = g_file_get_parent (_tmp16_);
			config_parent = _tmp17_;
			_tmp18_ = config_parent;
			_tmp19_ = g_file_query_exists (_tmp18_, NULL);
			if (!_tmp19_) {
				{
					GFile* _tmp20_ = NULL;
					_tmp20_ = config_parent;
					g_file_make_directory_with_parents (_tmp20_, NULL, &_inner_error_);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch1_g_error;
					}
				}
				goto __finally1;
				__catch1_g_error:
				{
					GError* e = NULL;
					GError* _tmp21_ = NULL;
					const gchar* _tmp22_ = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					_tmp21_ = e;
					_tmp22_ = _tmp21_->message;
					g_message ("autostart.vala:58: %s", _tmp22_);
					_g_error_free0 (e);
				}
				__finally1:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (config_parent);
					_g_object_unref0 (file);
					_g_free0 (config_system_path);
					_g_object_unref0 (config_file);
					_g_free0 (config_path);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			{
				GFile* _tmp23_ = NULL;
				GFile* _tmp24_ = NULL;
				_tmp23_ = file;
				_tmp24_ = config_file;
				g_file_copy (_tmp23_, _tmp24_, G_FILE_COPY_NONE, NULL, NULL, NULL, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch2_g_error;
				}
			}
			goto __finally2;
			__catch2_g_error:
			{
				GError* e = NULL;
				GError* _tmp25_ = NULL;
				const gchar* _tmp26_ = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp25_ = e;
				_tmp26_ = _tmp25_->message;
				g_message ("autostart.vala:68: %s", _tmp26_);
				_g_error_free0 (e);
			}
			__finally2:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (config_parent);
				_g_object_unref0 (file);
				_g_free0 (config_system_path);
				_g_object_unref0 (config_file);
				_g_free0 (config_path);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_g_object_unref0 (config_parent);
			_g_object_unref0 (file);
		}
		_g_free0 (config_system_path);
	}
	_tmp27_ = config_path;
	g_message ("autostart.vala:72: Conf file for autostart: %s", _tmp27_);
	result = config_path;
	_g_object_unref0 (config_file);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->builder);
		g_slice_free (Block1Data, _data1_);
	}
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_object_unref0 (_data2_->add_entry);
		block1_data_unref (_data2_->_data1_);
		_data2_->_data1_ = NULL;
		g_slice_free (Block2Data, _data2_);
	}
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		_g_object_unref0 (_data3_->check);
		block2_data_unref (_data3_->_data2_);
		_data3_->_data2_ = NULL;
		g_slice_free (Block3Data, _data3_);
	}
}


static gchar* g_file_stream_read_line (FILE* self) {
	gchar* result = NULL;
	gint c = 0;
	GString* ret = NULL;
	GString* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	ret = NULL;
	while (TRUE) {
		gint _tmp0_ = 0;
		gint _tmp1_ = 0;
		GString* _tmp2_ = NULL;
		gint _tmp4_ = 0;
		GString* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		_tmp0_ = fgetc (self);
		c = _tmp0_;
		_tmp1_ = c;
		if (!(_tmp1_ != EOF)) {
			break;
		}
		_tmp2_ = ret;
		if (_tmp2_ == NULL) {
			GString* _tmp3_ = NULL;
			_tmp3_ = g_string_new ("");
			_g_string_free0 (ret);
			ret = _tmp3_;
		}
		_tmp4_ = c;
		if (_tmp4_ == ((gint) '\n')) {
			break;
		}
		_tmp5_ = ret;
		_tmp6_ = c;
		g_string_append_c ((GString*) _tmp5_, (gchar) _tmp6_);
	}
	_tmp7_ = ret;
	if (_tmp7_ == NULL) {
		result = NULL;
		_g_string_free0 (ret);
		return result;
	} else {
		GString* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		_tmp8_ = ret;
		_tmp9_ = ((GString*) _tmp8_)->str;
		_tmp10_ = g_strdup (_tmp9_);
		result = _tmp10_;
		_g_string_free0 (ret);
		return result;
	}
	_g_string_free0 (ret);
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	glong string_length = 0L;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	glong _tmp2_ = 0L;
	glong _tmp5_ = 0L;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_ = 0L;
	gboolean _tmp12_ = FALSE;
	glong _tmp13_ = 0L;
	glong _tmp16_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	gchar* _tmp21_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_ = 0L;
		glong _tmp7_ = 0L;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	g_return_val_if_fail (_tmp8_, NULL);
	_tmp13_ = end;
	if (_tmp13_ >= ((glong) 0)) {
		glong _tmp14_ = 0L;
		glong _tmp15_ = 0L;
		_tmp14_ = end;
		_tmp15_ = string_length;
		_tmp12_ = _tmp14_ <= _tmp15_;
	} else {
		_tmp12_ = FALSE;
	}
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp16_ = start;
	_tmp17_ = end;
	g_return_val_if_fail (_tmp16_ <= _tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	_tmp20_ = start;
	_tmp21_ = g_strndup (((gchar*) self) + _tmp18_, (gsize) (_tmp19_ - _tmp20_));
	result = _tmp21_;
	return result;
}


static void ____lambda4_ (Block3Data* _data3_) {
	Block2Data* _data2_;
	Block1Data* _data1_;
	GtkCheckButton* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GtkCheckButton* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	_data2_ = _data3_->_data2_;
	_data1_ = _data2_->_data1_;
	_tmp0_ = _data3_->check;
	_tmp1_ = gtk_button_get_label ((GtkButton*) _tmp0_);
	g_message ("autostart.vala:113: Label to update : %s", _tmp1_);
	_tmp2_ = _data3_->check;
	_tmp3_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp2_);
	if (_tmp3_) {
		GtkCheckButton* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp4_ = _data3_->check;
		_tmp5_ = gtk_button_get_label ((GtkButton*) _tmp4_);
		_tmp6_ = string_slice (_tmp5_, (glong) 0, (glong) 1);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strcmp0 (_tmp7_, "#") == 0;
		_g_free0 (_tmp7_);
		if (_tmp8_) {
			GtkCheckButton* _tmp9_ = NULL;
			const gchar* _tmp10_ = NULL;
			GtkBuilder* _tmp11_ = NULL;
			GtkCheckButton* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			_tmp9_ = _data3_->check;
			_tmp10_ = gtk_button_get_label ((GtkButton*) _tmp9_);
			_tmp11_ = _data1_->builder;
			ldefault_apps_update_autostart_conf (_tmp10_, "activate", _tmp11_);
			_tmp12_ = _data3_->check;
			_tmp13_ = gtk_button_get_label ((GtkButton*) _tmp12_);
			g_message ("autostart.vala:119: Activate : %s", _tmp13_);
		}
	} else {
		GtkCheckButton* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		gboolean _tmp18_ = FALSE;
		_tmp14_ = _data3_->check;
		_tmp15_ = gtk_button_get_label ((GtkButton*) _tmp14_);
		_tmp16_ = string_slice (_tmp15_, (glong) 0, (glong) 1);
		_tmp17_ = _tmp16_;
		_tmp18_ = g_strcmp0 (_tmp17_, "#") != 0;
		_g_free0 (_tmp17_);
		if (_tmp18_) {
			GtkCheckButton* _tmp19_ = NULL;
			const gchar* _tmp20_ = NULL;
			GtkBuilder* _tmp21_ = NULL;
			GtkCheckButton* _tmp22_ = NULL;
			const gchar* _tmp23_ = NULL;
			_tmp19_ = _data3_->check;
			_tmp20_ = gtk_button_get_label ((GtkButton*) _tmp19_);
			_tmp21_ = _data1_->builder;
			ldefault_apps_update_autostart_conf (_tmp20_, "desactivate", _tmp21_);
			_tmp22_ = _data3_->check;
			_tmp23_ = gtk_button_get_label ((GtkButton*) _tmp22_);
			g_message ("autostart.vala:127: Deactivate : %s", _tmp23_);
		}
	}
}


static void _____lambda4__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	____lambda4_ (self);
}


static void ____lambda5_ (Block3Data* _data3_) {
	Block2Data* _data2_;
	Block1Data* _data1_;
	GtkCheckButton* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GtkBuilder* _tmp2_ = NULL;
	GtkCheckButton* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	_data2_ = _data3_->_data2_;
	_data1_ = _data2_->_data1_;
	_tmp0_ = _data3_->check;
	_tmp1_ = gtk_button_get_label ((GtkButton*) _tmp0_);
	_tmp2_ = _data1_->builder;
	ldefault_apps_update_autostart_conf (_tmp1_, "remove", _tmp2_);
	_tmp3_ = _data3_->check;
	_tmp4_ = gtk_button_get_label ((GtkButton*) _tmp3_);
	g_message ("autostart.vala:137: try to remove : %s", _tmp4_);
}


static void _____lambda5__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	____lambda5_ (self);
}


static void ___lambda6_ (Block2Data* _data2_) {
	Block1Data* _data1_;
	GtkEntry* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GtkBuilder* _tmp2_ = NULL;
	GtkEntry* _tmp3_ = NULL;
	_data1_ = _data2_->_data1_;
	_tmp0_ = _data2_->add_entry;
	_tmp1_ = gtk_entry_get_text (_tmp0_);
	_tmp2_ = _data1_->builder;
	ldefault_apps_update_autostart_conf (_tmp1_, "add", _tmp2_);
	_tmp3_ = _data2_->add_entry;
	gtk_entry_set_text (_tmp3_, "");
}


static void ____lambda6__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	___lambda6_ (self);
}


void ldefault_apps_manual_autostart_init (GtkBuilder* builder) {
	Block1Data* _data1_;
	GtkBuilder* _tmp0_ = NULL;
	GtkBuilder* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (builder != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = builder;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data1_->builder);
	_data1_->builder = _tmp1_;
	_tmp2_ = ldefault_apps_read_autostart_conf ();
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_ == NULL;
	_g_free0 (_tmp3_);
	if (_tmp4_) {
		g_message ("autostart.vala:80: Can't find an autostart file, abort");
	} else {
		Block2Data* _data2_;
		FILE* stream = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		FILE* _tmp7_ = NULL;
		FILE* _tmp8_ = NULL;
		FILE* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		GtkAlignment* auto_align = NULL;
		GtkBuilder* _tmp12_ = NULL;
		GObject* _tmp13_ = NULL;
		GtkAlignment* _tmp14_ = NULL;
		GtkVBox* auto_vbox = NULL;
		GtkBuilder* _tmp15_ = NULL;
		GObject* _tmp16_ = NULL;
		GtkVBox* _tmp17_ = NULL;
		GtkVBox* _tmp18_ = NULL;
		GList* _tmp19_ = NULL;
		gchar* line = NULL;
		GtkHBox* add_hbox = NULL;
		GtkHBox* _tmp44_ = NULL;
		GtkButton* add_button = NULL;
		GtkButton* _tmp45_ = NULL;
		GtkEntry* _tmp46_ = NULL;
		GtkHBox* _tmp47_ = NULL;
		GtkButton* _tmp48_ = NULL;
		GtkHBox* _tmp49_ = NULL;
		GtkEntry* _tmp50_ = NULL;
		GtkVBox* _tmp51_ = NULL;
		GtkHBox* _tmp52_ = NULL;
		GtkAlignment* _tmp53_ = NULL;
		GtkVBox* _tmp54_ = NULL;
		GtkButton* _tmp55_ = NULL;
		GtkVBox* _tmp56_ = NULL;
		_data2_ = g_slice_new0 (Block2Data);
		_data2_->_ref_count_ = 1;
		_data2_->_data1_ = block1_data_ref (_data1_);
		_tmp5_ = ldefault_apps_read_autostart_conf ();
		_tmp6_ = _tmp5_;
		_tmp7_ = g_fopen (_tmp6_, "r");
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		stream = _tmp8_;
		_tmp9_ = stream;
		_vala_assert (_tmp9_ != NULL, "stream != null");
		_tmp10_ = ldefault_apps_read_autostart_conf ();
		_tmp11_ = _tmp10_;
		g_message ("autostart.vala:87: Autostart conf file : %s", _tmp11_);
		_g_free0 (_tmp11_);
		_tmp12_ = _data1_->builder;
		_tmp13_ = gtk_builder_get_object (_tmp12_, "autostart_alignment");
		_tmp14_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp13_, GTK_TYPE_ALIGNMENT) ? ((GtkAlignment*) _tmp13_) : NULL);
		auto_align = _tmp14_;
		_tmp15_ = _data1_->builder;
		_tmp16_ = gtk_builder_get_object (_tmp15_, "manual_autostart_vbox");
		_tmp17_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp16_, GTK_TYPE_VBOX) ? ((GtkVBox*) _tmp16_) : NULL);
		auto_vbox = _tmp17_;
		_tmp18_ = auto_vbox;
		_tmp19_ = gtk_container_get_children ((GtkContainer*) _tmp18_);
		{
			GList* widget_collection = NULL;
			GList* widget_it = NULL;
			widget_collection = _tmp19_;
			for (widget_it = widget_collection; widget_it != NULL; widget_it = widget_it->next) {
				GtkWidget* widget = NULL;
				widget = (GtkWidget*) widget_it->data;
				{
					GtkVBox* _tmp20_ = NULL;
					GtkWidget* _tmp21_ = NULL;
					_tmp20_ = auto_vbox;
					_tmp21_ = widget;
					gtk_container_remove ((GtkContainer*) _tmp20_, _tmp21_);
				}
			}
			_g_list_free0 (widget_collection);
		}
		line = NULL;
		while (TRUE) {
			Block3Data* _data3_;
			FILE* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			const gchar* _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			GtkHBox* hbox = NULL;
			GtkHBox* _tmp26_ = NULL;
			const gchar* _tmp27_ = NULL;
			GtkCheckButton* _tmp28_ = NULL;
			const gchar* _tmp29_ = NULL;
			gchar* _tmp30_ = NULL;
			gchar* _tmp31_ = NULL;
			gboolean _tmp32_ = FALSE;
			GtkCheckButton* _tmp35_ = NULL;
			GtkHBox* _tmp36_ = NULL;
			GtkCheckButton* _tmp37_ = NULL;
			GtkButton* button = NULL;
			GtkButton* _tmp38_ = NULL;
			GtkButton* _tmp39_ = NULL;
			GtkHBox* _tmp40_ = NULL;
			GtkButton* _tmp41_ = NULL;
			GtkVBox* _tmp42_ = NULL;
			GtkHBox* _tmp43_ = NULL;
			_data3_ = g_slice_new0 (Block3Data);
			_data3_->_ref_count_ = 1;
			_data3_->_data2_ = block2_data_ref (_data2_);
			_tmp22_ = stream;
			_tmp23_ = g_file_stream_read_line (_tmp22_);
			_g_free0 (line);
			line = _tmp23_;
			_tmp24_ = line;
			if (!(_tmp24_ != NULL)) {
				block3_data_unref (_data3_);
				_data3_ = NULL;
				break;
			}
			_tmp25_ = line;
			g_message ("autostart.vala:100: Autostart line : %s", _tmp25_);
			_tmp26_ = (GtkHBox*) gtk_hbox_new (FALSE, 0);
			g_object_ref_sink (_tmp26_);
			hbox = _tmp26_;
			_tmp27_ = line;
			_tmp28_ = (GtkCheckButton*) gtk_check_button_new_with_label (_tmp27_);
			g_object_ref_sink (_tmp28_);
			_data3_->check = _tmp28_;
			_tmp29_ = line;
			_tmp30_ = string_slice (_tmp29_, (glong) 0, (glong) 1);
			_tmp31_ = _tmp30_;
			_tmp32_ = g_strcmp0 (_tmp31_, "#") == 0;
			_g_free0 (_tmp31_);
			if (_tmp32_) {
				GtkCheckButton* _tmp33_ = NULL;
				_tmp33_ = _data3_->check;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp33_, FALSE);
			} else {
				GtkCheckButton* _tmp34_ = NULL;
				_tmp34_ = _data3_->check;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp34_, TRUE);
			}
			_tmp35_ = _data3_->check;
			g_signal_connect_data ((GtkToggleButton*) _tmp35_, "toggled", (GCallback) _____lambda4__gtk_toggle_button_toggled, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
			_tmp36_ = hbox;
			_tmp37_ = _data3_->check;
			gtk_box_pack_start ((GtkBox*) _tmp36_, (GtkWidget*) _tmp37_, FALSE, FALSE, (guint) 0);
			_tmp38_ = (GtkButton*) gtk_button_new_from_stock ("gtk-remove");
			g_object_ref_sink (_tmp38_);
			button = _tmp38_;
			_tmp39_ = button;
			g_signal_connect_data (_tmp39_, "clicked", (GCallback) _____lambda5__gtk_button_clicked, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
			_tmp40_ = hbox;
			_tmp41_ = button;
			gtk_box_pack_start ((GtkBox*) _tmp40_, (GtkWidget*) _tmp41_, FALSE, FALSE, (guint) 0);
			_tmp42_ = auto_vbox;
			_tmp43_ = hbox;
			gtk_box_pack_start ((GtkBox*) _tmp42_, (GtkWidget*) _tmp43_, FALSE, FALSE, (guint) 0);
			_g_object_unref0 (button);
			_g_object_unref0 (hbox);
			block3_data_unref (_data3_);
			_data3_ = NULL;
		}
		_tmp44_ = (GtkHBox*) gtk_hbox_new (FALSE, 0);
		g_object_ref_sink (_tmp44_);
		add_hbox = _tmp44_;
		_tmp45_ = (GtkButton*) gtk_button_new_from_stock ("gtk-add");
		g_object_ref_sink (_tmp45_);
		add_button = _tmp45_;
		_tmp46_ = (GtkEntry*) gtk_entry_new ();
		g_object_ref_sink (_tmp46_);
		_data2_->add_entry = _tmp46_;
		_tmp47_ = add_hbox;
		_tmp48_ = add_button;
		gtk_box_pack_start ((GtkBox*) _tmp47_, (GtkWidget*) _tmp48_, FALSE, FALSE, (guint) 0);
		_tmp49_ = add_hbox;
		_tmp50_ = _data2_->add_entry;
		gtk_box_pack_start ((GtkBox*) _tmp49_, (GtkWidget*) _tmp50_, FALSE, FALSE, (guint) 0);
		_tmp51_ = auto_vbox;
		_tmp52_ = add_hbox;
		gtk_box_pack_start ((GtkBox*) _tmp51_, (GtkWidget*) _tmp52_, FALSE, FALSE, (guint) 0);
		_tmp53_ = auto_align;
		_tmp54_ = auto_vbox;
		gtk_container_add ((GtkContainer*) _tmp53_, (GtkWidget*) _tmp54_);
		_tmp55_ = add_button;
		g_signal_connect_data (_tmp55_, "clicked", (GCallback) ____lambda6__gtk_button_clicked, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
		_tmp56_ = auto_vbox;
		gtk_widget_show_all ((GtkWidget*) _tmp56_);
		_g_object_unref0 (add_button);
		_g_object_unref0 (add_hbox);
		_g_free0 (line);
		_g_object_unref0 (auto_vbox);
		_g_object_unref0 (auto_align);
		_fclose0 (stream);
		block2_data_unref (_data2_);
		_data2_ = NULL;
	}
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


void ldefault_apps_update_autostart_conf (const gchar* line, const gchar* action, GtkBuilder* builder) {
	GString* new_line = NULL;
	GString* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GQuark _tmp4_ = 0U;
	static GQuark _tmp3_label0 = 0;
	static GQuark _tmp3_label1 = 0;
	static GQuark _tmp3_label2 = 0;
	static GQuark _tmp3_label3 = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (line != NULL);
	g_return_if_fail (action != NULL);
	g_return_if_fail (builder != NULL);
	_tmp0_ = g_string_new ("");
	new_line = _tmp0_;
	_tmp1_ = action;
	_tmp2_ = _tmp1_;
	_tmp4_ = (NULL == _tmp2_) ? 0 : g_quark_from_string (_tmp2_);
	if (_tmp4_ == ((0 != _tmp3_label0) ? _tmp3_label0 : (_tmp3_label0 = g_quark_from_static_string ("activate")))) {
		switch (0) {
			default:
			{
				GString* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				GString* _tmp7_ = NULL;
				GString* _tmp8_ = NULL;
				_tmp5_ = new_line;
				_tmp6_ = line;
				g_string_append (_tmp5_, _tmp6_);
				_tmp7_ = new_line;
				g_string_erase (_tmp7_, (gssize) 0, (gssize) 1);
				_tmp8_ = new_line;
				g_string_append (_tmp8_, "\n");
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label1) ? _tmp3_label1 : (_tmp3_label1 = g_quark_from_static_string ("desactivate")))) {
		switch (0) {
			default:
			{
				GString* _tmp9_ = NULL;
				GString* _tmp10_ = NULL;
				const gchar* _tmp11_ = NULL;
				GString* _tmp12_ = NULL;
				_tmp9_ = new_line;
				g_string_append (_tmp9_, "#");
				_tmp10_ = new_line;
				_tmp11_ = line;
				g_string_append (_tmp10_, _tmp11_);
				_tmp12_ = new_line;
				g_string_append (_tmp12_, "\n");
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label2) ? _tmp3_label2 : (_tmp3_label2 = g_quark_from_static_string ("add")))) {
		switch (0) {
			default:
			{
				GString* _tmp13_ = NULL;
				const gchar* _tmp14_ = NULL;
				GString* _tmp15_ = NULL;
				_tmp13_ = new_line;
				_tmp14_ = line;
				g_string_append (_tmp13_, _tmp14_);
				_tmp15_ = new_line;
				g_string_append (_tmp15_, "\n");
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label3) ? _tmp3_label3 : (_tmp3_label3 = g_quark_from_static_string ("remove")))) {
		switch (0) {
			default:
			{
				break;
			}
		}
	}
	{
		gchar* tmp_path = NULL;
		const gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		GFile* tmp_file = NULL;
		const gchar* _tmp18_ = NULL;
		GFile* _tmp19_ = NULL;
		GFile* dest_file = NULL;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_ = NULL;
		GFile* _tmp22_ = NULL;
		GFile* _tmp23_ = NULL;
		FILE* stream = NULL;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		FILE* _tmp26_ = NULL;
		FILE* _tmp27_ = NULL;
		GFileOutputStream* _tmp28_ = NULL;
		GFile* _tmp29_ = NULL;
		GFileOutputStream* _tmp30_ = NULL;
		GDataOutputStream* tmp_stream = NULL;
		GDataOutputStream* _tmp31_ = NULL;
		FILE* _tmp32_ = NULL;
		gchar* read = NULL;
		const gchar* _tmp46_ = NULL;
		GFile* _tmp50_ = NULL;
		GFile* _tmp51_ = NULL;
		GFile* _tmp52_ = NULL;
		GtkBuilder* _tmp53_ = NULL;
		_tmp16_ = g_get_user_cache_dir ();
		_tmp17_ = g_build_filename (_tmp16_, "lxsession-default-apps", "autostart.tmp", NULL);
		tmp_path = _tmp17_;
		_tmp18_ = tmp_path;
		_tmp19_ = g_file_new_for_path (_tmp18_);
		tmp_file = _tmp19_;
		_tmp20_ = ldefault_apps_read_autostart_conf ();
		_tmp21_ = _tmp20_;
		_tmp22_ = g_file_new_for_path (_tmp21_);
		_tmp23_ = _tmp22_;
		_g_free0 (_tmp21_);
		dest_file = _tmp23_;
		_tmp24_ = ldefault_apps_read_autostart_conf ();
		_tmp25_ = _tmp24_;
		_tmp26_ = g_fopen (_tmp25_, "r");
		_tmp27_ = _tmp26_;
		_g_free0 (_tmp25_);
		stream = _tmp27_;
		_tmp29_ = tmp_file;
		_tmp30_ = g_file_create (_tmp29_, G_FILE_CREATE_REPLACE_DESTINATION, NULL, &_inner_error_);
		_tmp28_ = _tmp30_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_fclose0 (stream);
			_g_object_unref0 (dest_file);
			_g_object_unref0 (tmp_file);
			_g_free0 (tmp_path);
			goto __catch3_g_error;
		}
		_tmp31_ = g_data_output_stream_new ((GOutputStream*) _tmp28_);
		tmp_stream = _tmp31_;
		_tmp32_ = stream;
		_vala_assert (_tmp32_ != NULL, "stream != null");
		read = NULL;
		while (TRUE) {
			FILE* _tmp33_ = NULL;
			gchar* _tmp34_ = NULL;
			const gchar* _tmp35_ = NULL;
			const gchar* _tmp36_ = NULL;
			const gchar* _tmp37_ = NULL;
			const gchar* _tmp38_ = NULL;
			const gchar* _tmp39_ = NULL;
			_tmp33_ = stream;
			_tmp34_ = g_file_stream_read_line (_tmp33_);
			_g_free0 (read);
			read = _tmp34_;
			_tmp35_ = read;
			if (!(_tmp35_ != NULL)) {
				break;
			}
			_tmp36_ = read;
			g_message ("autostart.vala:196: read : %s", _tmp36_);
			_tmp37_ = line;
			g_message ("autostart.vala:197: line : %s", _tmp37_);
			_tmp38_ = read;
			_tmp39_ = line;
			if (g_strcmp0 (_tmp38_, _tmp39_) == 0) {
				GDataOutputStream* _tmp40_ = NULL;
				GString* _tmp41_ = NULL;
				const gchar* _tmp42_ = NULL;
				_tmp40_ = tmp_stream;
				_tmp41_ = new_line;
				_tmp42_ = _tmp41_->str;
				g_data_output_stream_put_string (_tmp40_, _tmp42_, NULL, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_free0 (read);
					_g_object_unref0 (tmp_stream);
					_g_object_unref0 (_tmp28_);
					_fclose0 (stream);
					_g_object_unref0 (dest_file);
					_g_object_unref0 (tmp_file);
					_g_free0 (tmp_path);
					goto __catch3_g_error;
				}
			} else {
				GDataOutputStream* _tmp43_ = NULL;
				const gchar* _tmp44_ = NULL;
				GDataOutputStream* _tmp45_ = NULL;
				_tmp43_ = tmp_stream;
				_tmp44_ = read;
				g_data_output_stream_put_string (_tmp43_, _tmp44_, NULL, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_free0 (read);
					_g_object_unref0 (tmp_stream);
					_g_object_unref0 (_tmp28_);
					_fclose0 (stream);
					_g_object_unref0 (dest_file);
					_g_object_unref0 (tmp_file);
					_g_free0 (tmp_path);
					goto __catch3_g_error;
				}
				_tmp45_ = tmp_stream;
				g_data_output_stream_put_string (_tmp45_, "\n", NULL, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_free0 (read);
					_g_object_unref0 (tmp_stream);
					_g_object_unref0 (_tmp28_);
					_fclose0 (stream);
					_g_object_unref0 (dest_file);
					_g_object_unref0 (tmp_file);
					_g_free0 (tmp_path);
					goto __catch3_g_error;
				}
			}
		}
		_tmp46_ = action;
		if (g_strcmp0 (_tmp46_, "add") == 0) {
			GDataOutputStream* _tmp47_ = NULL;
			GString* _tmp48_ = NULL;
			const gchar* _tmp49_ = NULL;
			_tmp47_ = tmp_stream;
			_tmp48_ = new_line;
			_tmp49_ = _tmp48_->str;
			g_data_output_stream_put_string (_tmp47_, _tmp49_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (read);
				_g_object_unref0 (tmp_stream);
				_g_object_unref0 (_tmp28_);
				_fclose0 (stream);
				_g_object_unref0 (dest_file);
				_g_object_unref0 (tmp_file);
				_g_free0 (tmp_path);
				goto __catch3_g_error;
			}
		}
		_tmp50_ = tmp_file;
		_tmp51_ = dest_file;
		g_file_copy (_tmp50_, _tmp51_, G_FILE_COPY_OVERWRITE, NULL, NULL, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (read);
			_g_object_unref0 (tmp_stream);
			_g_object_unref0 (_tmp28_);
			_fclose0 (stream);
			_g_object_unref0 (dest_file);
			_g_object_unref0 (tmp_file);
			_g_free0 (tmp_path);
			goto __catch3_g_error;
		}
		_tmp52_ = tmp_file;
		g_file_delete (_tmp52_, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (read);
			_g_object_unref0 (tmp_stream);
			_g_object_unref0 (_tmp28_);
			_fclose0 (stream);
			_g_object_unref0 (dest_file);
			_g_object_unref0 (tmp_file);
			_g_free0 (tmp_path);
			goto __catch3_g_error;
		}
		_tmp53_ = builder;
		ldefault_apps_manual_autostart_init (_tmp53_);
		_g_free0 (read);
		_g_object_unref0 (tmp_stream);
		_g_object_unref0 (_tmp28_);
		_fclose0 (stream);
		_g_object_unref0 (dest_file);
		_g_object_unref0 (tmp_file);
		_g_free0 (tmp_path);
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		GError* _tmp54_ = NULL;
		const gchar* _tmp55_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp54_ = e;
		_tmp55_ = _tmp54_->message;
		g_message ("autostart.vala:221: %s", _tmp55_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_string_free0 (new_line);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_string_free0 (new_line);
}


void ldefault_apps_autostart_core_applications (GtkBuilder* builder, LDefaultAppsDbusBackend* dbus_backend) {
	g_return_if_fail (builder != NULL);
	g_return_if_fail (dbus_backend != NULL);
}


gchar* ldefault_apps_get_config_home_path (const gchar* conf_file) {
	gchar* result = NULL;
	gchar* user_config_dir = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (conf_file != NULL, NULL);
	_tmp0_ = g_get_user_config_dir ();
	_tmp1_ = g_getenv ("DESKTOP_SESSION");
	_tmp2_ = conf_file;
	_tmp3_ = g_build_filename (_tmp0_, "lxsession", _tmp1_, _tmp2_, NULL);
	user_config_dir = _tmp3_;
	result = user_config_dir;
	return result;
}


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


gchar* ldefault_apps_get_config_path (const gchar* conf_file) {
	gchar* result = NULL;
	gchar* final_config_file = NULL;
	gchar* user_config_dir = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	const gchar* _tmp24_ = NULL;
	g_return_val_if_fail (conf_file != NULL, NULL);
	_tmp0_ = conf_file;
	_tmp1_ = ldefault_apps_get_config_home_path (_tmp0_);
	user_config_dir = _tmp1_;
	_tmp2_ = user_config_dir;
	_tmp3_ = g_file_test (_tmp2_, G_FILE_TEST_EXISTS);
	if (_tmp3_) {
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp4_ = user_config_dir;
		g_message ("autostart.vala:275: User config used : %s", _tmp4_);
		_tmp5_ = user_config_dir;
		_tmp6_ = g_strdup (_tmp5_);
		_g_free0 (final_config_file);
		final_config_file = _tmp6_;
	} else {
		gchar** system_config_dirs = NULL;
		gchar** _tmp7_ = NULL;
		gchar** _tmp8_ = NULL;
		gchar** _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gint system_config_dirs_length1 = 0;
		gint _system_config_dirs_size_ = 0;
		gchar* config_system_location = NULL;
		gchar* path_system_config_file = NULL;
		gchar** _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		const gchar* _tmp21_ = NULL;
		const gchar* _tmp22_ = NULL;
		gchar* _tmp23_ = NULL;
		_tmp8_ = _tmp7_ = g_get_system_config_dirs ();
		_tmp9_ = (_tmp8_ != NULL) ? _vala_array_dup1 (_tmp8_, _vala_array_length (_tmp7_)) : ((gpointer) _tmp8_);
		_tmp9__length1 = _vala_array_length (_tmp7_);
		system_config_dirs = _tmp9_;
		system_config_dirs_length1 = _tmp9__length1;
		_system_config_dirs_size_ = system_config_dirs_length1;
		config_system_location = NULL;
		path_system_config_file = NULL;
		_tmp10_ = system_config_dirs;
		_tmp10__length1 = system_config_dirs_length1;
		{
			gchar** config_collection = NULL;
			gint config_collection_length1 = 0;
			gint _config_collection_size_ = 0;
			gint config_it = 0;
			config_collection = _tmp10_;
			config_collection_length1 = _tmp10__length1;
			for (config_it = 0; config_it < _tmp10__length1; config_it = config_it + 1) {
				gchar* _tmp11_ = NULL;
				gchar* config = NULL;
				_tmp11_ = g_strdup (config_collection[config_it]);
				config = _tmp11_;
				{
					const gchar* _tmp12_ = NULL;
					const gchar* _tmp13_ = NULL;
					gchar* _tmp14_ = NULL;
					const gchar* _tmp15_ = NULL;
					const gchar* _tmp16_ = NULL;
					gboolean _tmp17_ = FALSE;
					_tmp12_ = config;
					_tmp13_ = g_getenv ("DESKTOP_SESSION");
					_tmp14_ = g_build_filename (_tmp12_, "lxsession", _tmp13_, NULL);
					_g_free0 (config_system_location);
					config_system_location = _tmp14_;
					_tmp15_ = config_system_location;
					g_message ("autostart.vala:286: Config system location : %s", _tmp15_);
					_tmp16_ = config_system_location;
					_tmp17_ = g_file_test (_tmp16_, G_FILE_TEST_EXISTS);
					if (_tmp17_) {
						const gchar* _tmp18_ = NULL;
						const gchar* _tmp19_ = NULL;
						gchar* _tmp20_ = NULL;
						_tmp18_ = config_system_location;
						_tmp19_ = conf_file;
						_tmp20_ = g_build_filename (_tmp18_, _tmp19_, NULL);
						_g_free0 (path_system_config_file);
						path_system_config_file = _tmp20_;
						_g_free0 (config);
						break;
					}
					_g_free0 (config);
				}
			}
		}
		_tmp21_ = path_system_config_file;
		g_message ("autostart.vala:292: System system path location : %s", _tmp21_);
		_tmp22_ = path_system_config_file;
		_tmp23_ = g_strdup (_tmp22_);
		_g_free0 (final_config_file);
		final_config_file = _tmp23_;
		_g_free0 (path_system_config_file);
		_g_free0 (config_system_location);
		system_config_dirs = (_vala_array_free (system_config_dirs, system_config_dirs_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp24_ = final_config_file;
	g_message ("autostart.vala:296: Final file used : %s", _tmp24_);
	result = final_config_file;
	_g_free0 (user_config_dir);
	return result;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



