/* utils.c generated by valac 0.34.7, the Vala compiler
 * generated from utils.vala, do not modify */

/* 
    Copyright 2013 Julien Lavergne <gilir@ubuntu.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>


#define LDEFAULT_APPS_TYPE_LDEFAULT_APPS_SIGNALS (ldefault_apps_ldefault_apps_signals_get_type ())
#define LDEFAULT_APPS_LDEFAULT_APPS_SIGNALS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LDEFAULT_APPS_TYPE_LDEFAULT_APPS_SIGNALS, LDefaultAppsLDefaultAppsSignals))
#define LDEFAULT_APPS_LDEFAULT_APPS_SIGNALS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LDEFAULT_APPS_TYPE_LDEFAULT_APPS_SIGNALS, LDefaultAppsLDefaultAppsSignalsClass))
#define LDEFAULT_APPS_IS_LDEFAULT_APPS_SIGNALS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LDEFAULT_APPS_TYPE_LDEFAULT_APPS_SIGNALS))
#define LDEFAULT_APPS_IS_LDEFAULT_APPS_SIGNALS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LDEFAULT_APPS_TYPE_LDEFAULT_APPS_SIGNALS))
#define LDEFAULT_APPS_LDEFAULT_APPS_SIGNALS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LDEFAULT_APPS_TYPE_LDEFAULT_APPS_SIGNALS, LDefaultAppsLDefaultAppsSignalsClass))

typedef struct _LDefaultAppsLDefaultAppsSignals LDefaultAppsLDefaultAppsSignals;
typedef struct _LDefaultAppsLDefaultAppsSignalsClass LDefaultAppsLDefaultAppsSignalsClass;
typedef struct _LDefaultAppsLDefaultAppsSignalsPrivate LDefaultAppsLDefaultAppsSignalsPrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_key_file_unref0(var) ((var == NULL) ? NULL : (var = (g_key_file_unref (var), NULL)))

struct _LDefaultAppsLDefaultAppsSignals {
	GObject parent_instance;
	LDefaultAppsLDefaultAppsSignalsPrivate * priv;
};

struct _LDefaultAppsLDefaultAppsSignalsClass {
	GObjectClass parent_class;
};


static gpointer ldefault_apps_ldefault_apps_signals_parent_class = NULL;

GType ldefault_apps_ldefault_apps_signals_get_type (void) G_GNUC_CONST;
enum  {
	LDEFAULT_APPS_LDEFAULT_APPS_SIGNALS_DUMMY_PROPERTY
};
LDefaultAppsLDefaultAppsSignals* ldefault_apps_ldefault_apps_signals_new (void);
LDefaultAppsLDefaultAppsSignals* ldefault_apps_ldefault_apps_signals_construct (GType object_type);
GKeyFile* ldefault_apps_load_key_conf (const gchar* config_path_directory, const gchar* conf_name);


LDefaultAppsLDefaultAppsSignals* ldefault_apps_ldefault_apps_signals_construct (GType object_type) {
	LDefaultAppsLDefaultAppsSignals * self = NULL;
	self = (LDefaultAppsLDefaultAppsSignals*) g_object_new (object_type, NULL);
	return self;
}


LDefaultAppsLDefaultAppsSignals* ldefault_apps_ldefault_apps_signals_new (void) {
	return ldefault_apps_ldefault_apps_signals_construct (LDEFAULT_APPS_TYPE_LDEFAULT_APPS_SIGNALS);
}


static void ldefault_apps_ldefault_apps_signals_class_init (LDefaultAppsLDefaultAppsSignalsClass * klass) {
	ldefault_apps_ldefault_apps_signals_parent_class = g_type_class_peek_parent (klass);
	g_signal_new ("update_ui", LDEFAULT_APPS_TYPE_LDEFAULT_APPS_SIGNALS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void ldefault_apps_ldefault_apps_signals_instance_init (LDefaultAppsLDefaultAppsSignals * self) {
}


GType ldefault_apps_ldefault_apps_signals_get_type (void) {
	static volatile gsize ldefault_apps_ldefault_apps_signals_type_id__volatile = 0;
	if (g_once_init_enter (&ldefault_apps_ldefault_apps_signals_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LDefaultAppsLDefaultAppsSignalsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ldefault_apps_ldefault_apps_signals_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LDefaultAppsLDefaultAppsSignals), 0, (GInstanceInitFunc) ldefault_apps_ldefault_apps_signals_instance_init, NULL };
		GType ldefault_apps_ldefault_apps_signals_type_id;
		ldefault_apps_ldefault_apps_signals_type_id = g_type_register_static (G_TYPE_OBJECT, "LDefaultAppsLDefaultAppsSignals", &g_define_type_info, 0);
		g_once_init_leave (&ldefault_apps_ldefault_apps_signals_type_id__volatile, ldefault_apps_ldefault_apps_signals_type_id);
	}
	return ldefault_apps_ldefault_apps_signals_type_id__volatile;
}


GKeyFile* ldefault_apps_load_key_conf (const gchar* config_path_directory, const gchar* conf_name) {
	GKeyFile* result = NULL;
	GKeyFile* kf = NULL;
	GKeyFile* _tmp0_ = NULL;
	GFile* config_directory_file = NULL;
	const gchar* _tmp1_ = NULL;
	GFile* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* config_path = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	GFile* config_file = NULL;
	const gchar* _tmp7_ = NULL;
	GFile* _tmp8_ = NULL;
	GFile* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	GFile* _tmp15_ = NULL;
	gboolean _tmp16_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (config_path_directory != NULL, NULL);
	g_return_val_if_fail (conf_name != NULL, NULL);
	_tmp0_ = g_key_file_new ();
	kf = _tmp0_;
	_tmp1_ = config_path_directory;
	_tmp2_ = g_file_new_for_path (_tmp1_);
	config_directory_file = _tmp2_;
	_tmp3_ = config_path_directory;
	g_message ("utils.vala:30: config_path_directory: %s", _tmp3_);
	_tmp4_ = config_path_directory;
	_tmp5_ = conf_name;
	_tmp6_ = g_build_filename (_tmp4_, _tmp5_, NULL);
	config_path = _tmp6_;
	_tmp7_ = config_path;
	_tmp8_ = g_file_new_for_path (_tmp7_);
	config_file = _tmp8_;
	_tmp9_ = config_directory_file;
	_tmp10_ = g_file_query_exists (_tmp9_, NULL);
	if (!_tmp10_) {
		{
			GFile* _tmp11_ = NULL;
			_tmp11_ = config_directory_file;
			g_file_make_directory_with_parents (_tmp11_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch34_g_error;
			}
		}
		goto __finally34;
		__catch34_g_error:
		{
			GError* e = NULL;
			FILE* _tmp12_ = NULL;
			GError* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp12_ = stderr;
			_tmp13_ = e;
			_tmp14_ = _tmp13_->message;
			fprintf (_tmp12_, "Could not write settings: %s\n", _tmp14_);
			_g_error_free0 (e);
		}
		__finally34:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (config_file);
			_g_free0 (config_path);
			_g_object_unref0 (config_directory_file);
			_g_key_file_unref0 (kf);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp15_ = config_file;
	_tmp16_ = g_file_query_exists (_tmp15_, NULL);
	if (!_tmp16_) {
		{
			GFile* _tmp17_ = NULL;
			GFileOutputStream* _tmp18_ = NULL;
			GFileOutputStream* _tmp19_ = NULL;
			_tmp17_ = config_file;
			_tmp18_ = g_file_create (_tmp17_, G_FILE_CREATE_PRIVATE, NULL, &_inner_error_);
			_tmp19_ = _tmp18_;
			_g_object_unref0 (_tmp19_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch35_g_error;
			}
		}
		goto __finally35;
		__catch35_g_error:
		{
			GError* e = NULL;
			FILE* _tmp20_ = NULL;
			GError* _tmp21_ = NULL;
			const gchar* _tmp22_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp20_ = stderr;
			_tmp21_ = e;
			_tmp22_ = _tmp21_->message;
			fprintf (_tmp20_, "Could not write settings: %s\n", _tmp22_);
			_g_error_free0 (e);
		}
		__finally35:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (config_file);
			_g_free0 (config_path);
			_g_object_unref0 (config_directory_file);
			_g_key_file_unref0 (kf);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	{
		GKeyFile* _tmp23_ = NULL;
		const gchar* _tmp24_ = NULL;
		_tmp23_ = kf;
		_tmp24_ = config_path;
		g_key_file_load_from_file (_tmp23_, _tmp24_, G_KEY_FILE_NONE, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch36_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch36_g_file_error;
			}
			_g_object_unref0 (config_file);
			_g_free0 (config_path);
			_g_object_unref0 (config_directory_file);
			_g_key_file_unref0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	goto __finally36;
	__catch36_g_key_file_error:
	{
		GError* err = NULL;
		GError* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp25_ = err;
		_tmp26_ = _tmp25_->message;
		g_warning ("utils.vala:65: %s", _tmp26_);
		_g_error_free0 (err);
	}
	goto __finally36;
	__catch36_g_file_error:
	{
		GError* err = NULL;
		GError* _tmp27_ = NULL;
		const gchar* _tmp28_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp27_ = err;
		_tmp28_ = _tmp27_->message;
		g_warning ("utils.vala:69: %s", _tmp28_);
		_g_error_free0 (err);
	}
	__finally36:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (config_file);
		_g_free0 (config_path);
		_g_object_unref0 (config_directory_file);
		_g_key_file_unref0 (kf);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = kf;
	_g_object_unref0 (config_file);
	_g_free0 (config_path);
	_g_object_unref0 (config_directory_file);
	return result;
}



